ğŸ§­ ì „ì²´ êµ¬ì¡° ì„¤ê³„ ì§€ì¹¨ì„œ: ì¼ì • ìƒì„±/ì‚­ì œ ë¡œì§ (ì£¼ê°„/ì›”ê°„ ë°˜ë³µ ê¸°ì¤€)
ğŸ” 1. í•µì‹¬ ì •ì˜ ì •ë¦¬
í•­ëª©	ì •ì˜
ë°˜ë³µ ìœ í˜•	ì£¼ê°„ ë˜ëŠ” ì›”ê°„
ì£¼ê°„ ë°˜ë³µ	ë§¤ì£¼ íŠ¹ì • ìš”ì¼ì— ë°˜ë³µ (ì˜ˆ: ë§¤ì£¼ ì›”Â·ê¸ˆ)
ì›”ê°„ ë°˜ë³µ	ë§¤ì›” íŠ¹ì • ìš”ì¼/ë‚ ì§œ ê¸°ì¤€ ë°˜ë³µ (ì˜ˆ: ë§¤ì›” ì²« ë²ˆì§¸ ê¸ˆìš”ì¼ ë˜ëŠ” ë§¤ì›” 15ì¼)
ë°˜ë³µ íšŸìˆ˜	ë°˜ë³µ ìƒì„± íšŸìˆ˜ (0=ë¬´í•œ ìƒì„±)
ì‚­ì œ ê¸°ì¤€	ì„ íƒ ì¼ì • ì´í›„ë¶€í„° ì‚­ì œ OR ì „ì²´ ì‚­ì œ

ğŸ§± 2. UI êµ¬ì¡° ê¸°ì¤€ ë°ì´í„° ëª¨ë¸
ts
ë³µì‚¬
í¸ì§‘
interface RepeatSetting {
  repeatType: 'weekly' | 'monthly';     // ì£¼ê°„ or ì›”ê°„
  interval: number;                     // ë°˜ë³µ ê°„ê²© (1ì£¼, 2ì£¼, 1ë‹¬ ë“±)
  weekdays?: number[];                 // ì£¼ê°„ ë°˜ë³µ ì‹œ ìš”ì¼ (0: ì¼ ~ 6: í† )
  monthlyMode?: 'weekday' | 'date';     // ì›”ê°„ ë°˜ë³µ ê¸°ì¤€ (ìš”ì¼ or ë‚ ì§œ)
  repeatCount?: number;                 // ë°˜ë³µ íšŸìˆ˜ (ë¯¸ì…ë ¥ ì‹œ ë¬´í•œ ë°˜ë³µ)
  baseDate: string;                     // ê¸°ì¤€ ì‹œì‘ì¼
}
ğŸ“… 3. ì¼ì • ìƒì„± ë¡œì§: ì£¼ê°„ vs ì›”ê°„
âœ… A. ì£¼ê°„ ë°˜ë³µ ë¡œì§
ts
ë³µì‚¬
í¸ì§‘
function generateWeeklySchedules({ baseDate, interval, weekdays, repeatCount }) {
  const schedules = []
  const base = new Date(baseDate)
  let count = 0
  let currentWeekStart = new Date(base)

  while (!repeatCount || count < repeatCount) {
    weekdays.forEach((day) => {
      const date = new Date(currentWeekStart)
      date.setDate(date.getDate() + (day - date.getDay() + 7) % 7)
      const key = date.toISOString().split('T')[0]
      if (!schedules.find(d => d.date === key)) {
        schedules.push({ date: key })
      }
    })
    currentWeekStart.setDate(currentWeekStart.getDate() + 7 * interval)
    count++
  }

  return schedules
}
âœ… B. ì›”ê°„ ë°˜ë³µ ë¡œì§
ts
ë³µì‚¬
í¸ì§‘
function generateMonthlySchedules({ baseDate, interval, monthlyMode, weekdays, repeatCount }) {
  const schedules = []
  let current = new Date(baseDate)
  let count = 0

  while (!repeatCount || count < repeatCount) {
    if (monthlyMode === 'date') {
      const nextDate = new Date(current)
      nextDate.setMonth(current.getMonth() + interval)
      schedules.push({ date: nextDate.toISOString().split('T')[0] })
    } else if (monthlyMode === 'weekday') {
      weekdays.forEach((w) => {
        const date = getNthWeekdayOfMonth(current.getFullYear(), current.getMonth(), w)
        schedules.push({ date: date.toISOString().split('T')[0] })
      })
      current.setMonth(current.getMonth() + interval)
    }
    count++
  }

  return schedules
}
ğŸ”§ getNthWeekdayOfMonth()ëŠ” ë§¤ì›” në²ˆì§¸ ìš”ì¼ì„ ê³„ì‚°í•˜ëŠ” ìœ í‹¸ í•¨ìˆ˜ í•„ìš”.

ğŸ—‘ï¸ 4. ì¼ì • ì‚­ì œ ë¡œì§ ì§€ì¹¨
ğŸ’£ ë¬¸ì œ: ê¸°ì¤€ ë‚ ì§œ ì´í›„ ì‚­ì œ ì‹œ ì „ì²´ ì‚­ì œë˜ëŠ” í˜„ìƒ
âœ… í•´ê²° ì „ëµ:
ëª¨ë“  ë°˜ë³µ ì¼ì •ì— groupId ë¶€ì—¬

ì‚­ì œ ì‹œ ë‹¤ìŒ ì¡°ê±´ìœ¼ë¡œ í•„í„°ë§ ì ìš©

ts
ë³µì‚¬
í¸ì§‘
DELETE /schedule?groupId=abc123&fromDate=2025-07-12
ts
ë³µì‚¬
í¸ì§‘
// í•„í„° ì˜ˆì‹œ
const filtered = allSchedules.filter(s => 
  s.groupId === input.groupId && new Date(s.date) >= new Date(input.fromDate)
)
ğŸ“Œ 5. ì˜ˆì™¸ ë°©ì§€ ì¡°ê±´ ë¡œì§
ìƒí™©	ì²˜ë¦¬ ë¡œì§
ê¸°ì¤€ì¼ê³¼ ë°˜ë³µ ìš”ì¼ ê²¹ì¹¨	ì¤‘ë³µ ì œê±° (Set í™œìš©)
ë°˜ë³µ íšŸìˆ˜ 0	while(true) í˜•ì‹ìœ¼ë¡œ ì œí•œ ì—†ì´ ìƒì„±
ì›”ë§ 31ì¼ ë°˜ë³µ	ë§¤ì›” ì¼ìˆ˜ ì²´í¬í•˜ì—¬ ìœ íš¨í•œ ë§ˆì§€ë§‰ ë‚ ì§œë¡œ ë³´ì •

ğŸ“š ì ìš© ì˜ˆì‹œ
â–¶ ì‚¬ìš©ìê°€ ì„ íƒ:
ê¸°ì¤€ì¼: 2025-07-12(ê¸ˆ)

ë°˜ë³µ ìœ í˜•: ì£¼ê°„

ìš”ì¼: ì›”, ê¸ˆ

ë°˜ë³µ íšŸìˆ˜: 3íšŒ

â–¶ ìƒì„± ê²°ê³¼:
2025-07-12 (ê¸ˆ) â† ê¸°ì¤€ì¼ 1íšŒ

2025-07-15 (ì›”)

2025-07-19 (ê¸ˆ)

2025-07-22 (ì›”)

2025-07-26 (ê¸ˆ)

ğŸ›¡ ì¤‘ë³µ ë°©ì§€: ê¸°ì¤€ì¼ê³¼ ìš”ì¼ì´ ê²¹ì¹˜ëŠ” 2025-07-12ëŠ” 1íšŒë§Œ ìƒì„±ë¨

ğŸ§¾ ìµœì¢… ìš”ì•½
ê¸°ëŠ¥	êµ¬ì¡° ì„¤ëª…
ğŸ“… ì¼ì • ìƒì„±	repeatType, interval, weekdays, monthlyMode, repeatCount ë“± ëª…í™•í•œ ë°ì´í„° ëª¨ë¸ ì •ì˜
ğŸ” ë°˜ë³µ íšŸìˆ˜	0ì´ë©´ ë¬´í•œ, ì£¼ê°„=ì£¼ ë‹¨ìœ„ ë°˜ë³µ, ì›”ê°„=ì›” ë‹¨ìœ„ ë°˜ë³µ
ğŸ§½ ì‚­ì œ ê¸°ëŠ¥	groupId + fromDate ì¡°í•©ìœ¼ë¡œ ì´í›„ë§Œ ì‚­ì œë˜ë„ë¡ ë³´ì •
ğŸ›‘ ì¤‘ë³µ ë°©ì§€	Setìœ¼ë¡œ ë‚ ì§œ ì¤‘ë³µ ì œê±° / ê¸°ì¤€ì¼ ì²´í¬